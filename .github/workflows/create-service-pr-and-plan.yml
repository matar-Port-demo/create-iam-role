name: Create Service PR and Plan

on:
  workflow_dispatch:
    inputs:
      application_name:
        description: 'Application name'
        required: true
      stack_type:
        description: 'Stack type (Containerized/Non-containerized)'
        required: true
      description:
        description: 'Service description'
        required: false
      use_existing_repo:
        description: 'Use existing repository or create new'
        required: true
      repository:
        description: 'Existing repository identifier'
        required: false
      repository_name:
        description: 'New repository name'
        required: false
      runtime:
        description: 'Runtime (Python/Java/Go)'
        required: false
      database_setup:
        description: 'Database setup option'
        required: false
      k_8_s_setup:
        description: 'K8s setup option'
        required: false
      port_context:
        description: 'Port context object (includes runId)'
        required: true

permissions:
  contents: write
  pull-requests: write
  actions: read

env:
  BASE_TF_DIR: resources
  BRANCH_PREFIX: create-service
  MAIN_BRANCH: main

jobs:
  create-pr-and-plan:
    runs-on: ubuntu-latest
    outputs:
      service_repo_url: ${{ steps.setup_repo.outputs.repo_url }}
      cicd_pr_url: ${{ steps.create_cicd_pr.outputs.pull-request-url }}
      infra_pr_url: ${{ steps.create_infra_pr.outputs.pull-request-url }}
      port_run_id: ${{ steps.extract_run_id.outputs.PORT_RUN_ID }}
    steps:
      - name: Extract Port Run ID and Requestor
        id: extract_run_id
        run: |
          PORT_RUN_ID="${{ fromJson(github.event.inputs.port_context).runId }}"
          REQUESTOR_EMAIL="${{ fromJson(github.event.inputs.port_context).user.email }}"
          echo "PORT_RUN_ID=$PORT_RUN_ID" >> $GITHUB_ENV
          echo "REQUESTOR_EMAIL=$REQUESTOR_EMAIL" >> $GITHUB_ENV
          echo "::set-output name=PORT_RUN_ID::$PORT_RUN_ID"
          echo "::set-output name=REQUESTOR_EMAIL::$REQUESTOR_EMAIL"

      - name: Log start to Port
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ env.PORT_RUN_ID }}
          logMessage: "üöÄ Let's build your service `${{ github.event.inputs.application_name }}`!"

      - name: Setup Repository
        id: setup_repo
        run: |
          APP_NAME="${{ github.event.inputs.application_name }}"
          USE_EXISTING="${{ github.event.inputs.use_existing_repo }}"
          
          if [ "$USE_EXISTING" = "Create a new Repository" ]; then
            REPO_NAME="${{ github.event.inputs.repository_name }}"
            # Handle null string, empty, or unset values
            if [ -z "$REPO_NAME" ] || [ "$REPO_NAME" == "null" ] || [ "$REPO_NAME" == "undefined" ]; then
              REPO_NAME="$APP_NAME"
            fi
            
            echo "Creating new repository: $REPO_NAME"
            
            # Create repository via GitHub API
            CREATE_RESPONSE=$(curl -s -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GH_PAT }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d "{\"name\":\"$REPO_NAME\",\"private\":true,\"description\":\"${{ github.event.inputs.description }}\"}" \
              "https://api.github.com/orgs/${{ github.repository_owner }}/repos")
            
            REPO_URL=$(echo "$CREATE_RESPONSE" | jq -r '.html_url // empty')
            
            if [ -z "$REPO_URL" ] || [ "$REPO_URL" == "null" ]; then
              echo "‚ùå Failed to create repository"
              echo "Response: $CREATE_RESPONSE"
              exit 1
            fi
            
            echo "‚úÖ Repository created: $REPO_URL"
            echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT
            echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
            echo "repo_full_name=${{ github.repository_owner }}/$REPO_NAME" >> $GITHUB_OUTPUT
            echo "REPO_URL=$REPO_URL" >> $GITHUB_ENV
            echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
            echo "REPO_FULL_NAME=${{ github.repository_owner }}/$REPO_NAME" >> $GITHUB_ENV
          else
            # Use existing repository - get URL from Port entity
            REPO_IDENTIFIER="${{ github.event.inputs.repository }}"
            echo "Using existing repository: $REPO_IDENTIFIER"
            echo "repo_name=$REPO_IDENTIFIER" >> $GITHUB_OUTPUT
            echo "REPO_NAME=$REPO_IDENTIFIER" >> $GITHUB_ENV
            # Note: REPO_URL will be set after fetching from Port
          fi
      
      - name: Scaffold Repository from Cookiecutter Template
        if: github.event.inputs.use_existing_repo == 'Create a new Repository'
        id: scaffold_repo
        run: |
          APP_NAME="${{ github.event.inputs.application_name }}"
          REPO_NAME="${{ steps.setup_repo.outputs.repo_name }}"
          
          # Fallback if output is empty, null, or undefined
          if [ -z "$REPO_NAME" ] || [ "$REPO_NAME" == "null" ] || [ "$REPO_NAME" == "undefined" ]; then
            REPO_NAME="${{ github.event.inputs.repository_name }}"
            if [ -z "$REPO_NAME" ] || [ "$REPO_NAME" == "null" ] || [ "$REPO_NAME" == "undefined" ]; then
              REPO_NAME="$APP_NAME"
            fi
          fi
          
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "repo_full_name=${{ github.repository_owner }}/$REPO_NAME" >> $GITHUB_OUTPUT
          echo "Using repository name: $REPO_NAME"
      
      - name: Create GitHub Repository with Cookiecutter
        if: github.event.inputs.use_existing_repo == 'Create a new Repository'
        uses: port-labs/cookiecutter-gha@v1.1.1
        with:
          portClientId: ${{ secrets.PORT_CLIENT_ID }}
          portClientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          token: ${{ secrets.GH_PAT }}
          portRunId: ${{ env.PORT_RUN_ID }}
          repositoryName: ${{ steps.scaffold_repo.outputs.repo_name }}
          portUserInputs: |
            {
              "cookiecutter_app_name": "${{ github.event.inputs.application_name }}",
              "project_name": "${{ steps.scaffold_repo.outputs.repo_name }}",
              "repo_name": "${{ steps.scaffold_repo.outputs.repo_name }}",
              "project_short_description": "${{ github.event.inputs.description }}"
            }
          cookiecutterTemplate: https://github.com/audreyfeldroy/cookiecutter-pypackage
          blueprintIdentifier: "githubRepository"
          organizationName: ${{ github.repository_owner }}
          createPortEntity: false

      - name: Get existing repository URL from Port
        if: github.event.inputs.use_existing_repo == 'Use existing repository'
        id: get_repo_url
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: GET
          identifier: ${{ github.event.inputs.repository }}
          blueprint: githubRepository
        continue-on-error: true

      - name: Extract repository URL
        if: github.event.inputs.use_existing_repo == 'Use existing repository'
        run: |
          REPO_JSON='${{ steps.get_repo_url.outputs.entity }}'
          REPO_URL=$(echo "$REPO_JSON" | jq -r '.properties.url // empty')
          if [ -z "$REPO_URL" ] || [ "$REPO_URL" == "null" ]; then
            # Fallback: construct URL from identifier
            REPO_URL="https://github.com/${{ github.repository_owner }}/${{ github.event.inputs.repository }}"
          fi
          echo "REPO_URL=$REPO_URL" >> $GITHUB_ENV
          echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT

      - name: Log repository ready to Port
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ env.PORT_RUN_ID }}
          logMessage: "‚ú® Repository ready!"
          link: "[\"${{ env.REPO_URL }}\"]"

      - name: Checkout templates repo (for CI/CD templates)
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository }}
          token: ${{ secrets.GH_PAT }}
          path: templates-repo

      - name: Checkout Service Repository (if using existing)
        if: github.event.inputs.use_existing_repo == 'Use existing repository'
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository_owner }}/${{ steps.setup_repo.outputs.repo_name }}
          token: ${{ secrets.GH_PAT }}
          path: service-repo
      
      - name: Checkout Service Repository (if created via cookiecutter)
        if: github.event.inputs.use_existing_repo == 'Create a new Repository'
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository_owner }}/${{ steps.scaffold_repo.outputs.repo_name }}
          token: ${{ secrets.GH_PAT }}
          path: service-repo

      - name: Generate CI/CD Workflow
        run: |
          APP_NAME="${{ github.event.inputs.application_name }}"
          STACK_TYPE="${{ github.event.inputs.stack_type }}"
          RUNTIME="${{ github.event.inputs.runtime }}"
          
          mkdir -p service-repo/.github/workflows
          
          # Select appropriate CI/CD template based on stack type and runtime
          if [ "$STACK_TYPE" = "Containerized (GKE)" ]; then
            case "$RUNTIME" in
              "Python")
                TEMPLATE_PATH="templates-repo/templates/cicd/deploy-containerized-python.yml"
                ;;
              "Java")
                TEMPLATE_PATH="templates-repo/templates/cicd/deploy-containerized-java.yml"
                ;;
              "Go")
                TEMPLATE_PATH="templates-repo/templates/cicd/deploy-containerized-go.yml"
                ;;
              *)
                TEMPLATE_PATH="templates-repo/templates/cicd/deploy-containerized-python.yml"
                ;;
            esac
          else
            TEMPLATE_PATH="templates-repo/templates/cicd/deploy-non-containerized.yml"
          fi
          
          # Replace template variables
          sed -e "s/{{ application_name }}/$APP_NAME/g" \
              -e "s/{{ cluster_name }}/$APP_NAME-cluster/g" \
              -e "s/{{ region }}/us-central1/g" \
              -e "s/{{ project_id }}/PROJECT_ID/g" \
              "$TEMPLATE_PATH" > service-repo/.github/workflows/deploy.yml
          
          echo "‚úÖ CI/CD workflow generated from template: $TEMPLATE_PATH"

      - name: Create CI/CD PR in Service Repository
        id: create_cicd_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GH_PAT }}
          path: service-repo
          commit-message: "Add CI/CD workflow for ${{ github.event.inputs.application_name }}"
          branch: add-cicd-workflow-${{ github.run_id }}
          base: main
          title: "Add CI/CD workflow for ${{ github.event.inputs.application_name }}"
          body: |
            This PR adds CI/CD workflow configuration.
            
            **Changes:**
            - Added `.github/workflows/deploy.yml` workflow file
            - Configured for ${{ github.event.inputs.stack_type }}
            - Runtime: ${{ github.event.inputs.runtime }}
            
            **Waiting for approval in Port.**
          create-empty-commit: false
          
      - name: Debug CI/CD PR output
        run: |
          echo "CI/CD PR URL output: ${{ steps.create_cicd_pr.outputs.pull-request-url }}"
          echo "CI/CD PR number output: ${{ steps.create_cicd_pr.outputs.pull-request-number }}"
          echo "All CI/CD PR outputs:"
          echo "${{ toJSON(steps.create_cicd_pr.outputs) }}"

      - name: Log CI/CD PR creation to Port
        if: steps.create_cicd_pr.outputs.pull-request-url != ''
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ env.PORT_RUN_ID }}
          logMessage: "üéØ CI/CD workflow PR ready for review!"
          link: "[\"${{ steps.create_cicd_pr.outputs.pull-request-url }}\"]"
          
      - name: Determine Service Repository for Terraform
        id: determine_tf_repo
        run: |
          if [ "${{ github.event.inputs.use_existing_repo }}" = "Create a new Repository" ]; then
            REPO_NAME="${{ steps.scaffold_repo.outputs.repo_name }}"
          else
            REPO_NAME="${{ steps.setup_repo.outputs.repo_name }}"
          fi
          TF_REPO="${{ github.repository_owner }}/$REPO_NAME"
          echo "TF_REPO=$TF_REPO" >> $GITHUB_ENV
          echo "tf_repo=$TF_REPO" >> $GITHUB_OUTPUT
          echo "Using service repository for Terraform: $TF_REPO"
          
      
      - name: Checkout Service Repository for Terraform
        uses: actions/checkout@v3
        with:
          repository: ${{ env.TF_REPO }}
          token: ${{ secrets.GH_PAT }}
          path: terraform-repo
          ref: ${{ env.MAIN_BRANCH }}

      - name: Checkout templates repo (for Terraform templates)
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository }}
          token: ${{ secrets.GH_PAT }}
          path: terraform-templates-repo

      - name: Generate Infrastructure Terraform Files
        run: |
          APP_NAME="${{ github.event.inputs.application_name }}"
          STACK_TYPE="${{ github.event.inputs.stack_type }}"
          K8S_SETUP="${{ github.event.inputs.k_8_s_setup }}"
          DB_SETUP="${{ github.event.inputs.database_setup }}"
          TF_DIR="terraform-repo/${{ env.BASE_TF_DIR }}/$APP_NAME"
          
          mkdir -p "$TF_DIR"
          
          # Generate cluster.tf if needed
          if [ "$STACK_TYPE" = "Containerized (GKE)" ] && [ "$K8S_SETUP" = "Create a new Cluster" ]; then
            echo "Generating cluster Terraform config from template..."
            CLUSTER_NAME="$APP_NAME-cluster"
            PROJECT_ID="PROJECT_ID"
            REGION="us-central1"
            NODE_COUNT="3"
            MACHINE_TYPE="e2-medium"
            
            sed -e "s/{{ cluster_name }}/$CLUSTER_NAME/g" \
                -e "s/{{ project_id }}/$PROJECT_ID/g" \
                -e "s/{{ region }}/$REGION/g" \
                -e "s/{{ node_count }}/$NODE_COUNT/g" \
                -e "s/{{ machine_type }}/$MACHINE_TYPE/g" \
                "terraform-templates-repo/templates/gke-cluster.tf" > "$TF_DIR/cluster.tf"
          fi
          
          # Generate database.tf if needed
          if [ "$DB_SETUP" = "Create a new database" ]; then
            echo "Generating database Terraform config from template..."
            DB_NAME="$APP_NAME-db"
            PROJECT_ID="PROJECT_ID"
            REGION="us-central1"
            DB_VERSION="POSTGRES_14"
            DB_TIER="db-f1-micro"
            BACKUP_SCHEDULE="03:00"
            DB_USER="$APP_NAME-user"
            DB_PASSWORD="$(openssl rand -base64 32)"
            
            sed -e "s/{{ database_name }}/$DB_NAME/g" \
                -e "s/{{ project_id }}/$PROJECT_ID/g" \
                -e "s/{{ region }}/$REGION/g" \
                -e "s/{{ database_version }}/$DB_VERSION/g" \
                -e "s/{{ database_tier }}/$DB_TIER/g" \
                -e "s/{{ backup_schedule }}/$BACKUP_SCHEDULE/g" \
                -e "s/{{ database_user }}/$DB_USER/g" \
                -e "s/{{ database_password }}/$DB_PASSWORD/g" \
                "terraform-templates-repo/templates/database.tf" > "$TF_DIR/database.tf"
          fi
          
          echo "‚úÖ Infrastructure Terraform files generated"

      - name: Create Infrastructure PR
        id: create_infra_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GH_PAT }}
          path: terraform-repo
          commit-message: "Add infrastructure for service ${{ github.event.inputs.application_name }}"
          branch: ${{ env.BRANCH_PREFIX }}-${{ github.run_id }}
          base: ${{ env.MAIN_BRANCH }}
          title: "Create infrastructure for service ${{ github.event.inputs.application_name }}"
          body: "This PR adds infrastructure configuration (cluster and/or database) via Terraform. **Waiting for approval in Port.**"

      - name: Log Infrastructure PR creation to Port
        if: steps.create_infra_pr.outputs.pull-request-url != ''
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ env.PORT_RUN_ID }}
          logMessage: "üèóÔ∏è Infrastructure PR ready for review!"
          link: "[\"${{ steps.create_infra_pr.outputs.pull-request-url }}\"]"

      - name: Generate Mock Terraform Plan Output
        id: mock_plan
        run: |
          APP_NAME="${{ github.event.inputs.application_name }}"
          STACK_TYPE="${{ github.event.inputs.stack_type }}"
          K8S_SETUP="${{ github.event.inputs.k_8_s_setup }}"
          DB_SETUP="${{ github.event.inputs.database_setup }}"
          
          PLAN_FILE=$(mktemp)
          echo "Terraform will perform the following actions:" > "$PLAN_FILE"
          echo "" >> "$PLAN_FILE"
          
          RESOURCE_COUNT=0
          
          if [ "$STACK_TYPE" = "Containerized (GKE)" ] && [ "$K8S_SETUP" = "Create a new Cluster" ]; then
            echo "  # google_container_cluster.cluster will be created" >> "$PLAN_FILE"
            echo "  + resource \"google_container_cluster\" \"cluster\" {" >> "$PLAN_FILE"
            echo "      + name     = \"$APP_NAME-cluster\"" >> "$PLAN_FILE"
            echo "      + location = \"us-central1\"" >> "$PLAN_FILE"
            echo "      + initial_node_count = 3" >> "$PLAN_FILE"
            echo "      ..." >> "$PLAN_FILE"
            echo "    }" >> "$PLAN_FILE"
            echo "" >> "$PLAN_FILE"
            RESOURCE_COUNT=$((RESOURCE_COUNT + 1))
          fi
          
          if [ "$DB_SETUP" = "Create a new database" ]; then
            echo "  # google_sql_database_instance.database will be created" >> "$PLAN_FILE"
            echo "  + resource \"google_sql_database_instance\" \"database\" {" >> "$PLAN_FILE"
            echo "      + name             = \"$APP_NAME-db\"" >> "$PLAN_FILE"
            echo "      + database_version = \"POSTGRES_14\"" >> "$PLAN_FILE"
            echo "      + region           = \"us-central1\"" >> "$PLAN_FILE"
            echo "      ..." >> "$PLAN_FILE"
            echo "    }" >> "$PLAN_FILE"
            echo "" >> "$PLAN_FILE"
            RESOURCE_COUNT=$((RESOURCE_COUNT + 1))
          fi
          
          echo "Plan: $RESOURCE_COUNT to add, 0 to change, 0 to destroy." >> "$PLAN_FILE"
          
          PLAN_OUTPUT=$(cat "$PLAN_FILE")
          rm "$PLAN_FILE"
          
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          echo "$PLAN_OUTPUT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Log Terraform Plan to Port
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ env.PORT_RUN_ID }}
          logMessage: |
            üìã **Terraform Plan:**
            
            ```
            ${{ env.PLAN_OUTPUT }}
            ```
            
            ‚è≥ **All set! Waiting for approval...**

      - name: Build Terraform plan properties
        id: build_plan_properties
        run: |
          CODE_FENCE='```'
          PLAN_MARKDOWN="${CODE_FENCE}"$'\n'"${PLAN_OUTPUT}"$'\n'"${CODE_FENCE}"
          PROPERTIES_JSON=$(jq -n --arg markdown "$PLAN_MARKDOWN" '{"terraform_plan": $markdown}')
          echo "PROPERTIES_JSON<<EOF" >> $GITHUB_OUTPUT
          echo "$PROPERTIES_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          PLAN_OUTPUT: ${{ env.PLAN_OUTPUT }}

      - name: Build PR URLs array
        id: build_pr_urls
        run: |
          INFRA_PR_URL="${{ steps.create_infra_pr.outputs.pull-request-url }}"
          CICD_PR_URL="${{ steps.create_cicd_pr.outputs.pull-request-url }}"
          
          # Build array of PR URLs (filter out empty values)
          PR_URLS_ARRAY="[]"
          if [ -n "$INFRA_PR_URL" ] && [ "$INFRA_PR_URL" != "null" ] && [ "$INFRA_PR_URL" != "" ]; then
            PR_URLS_ARRAY=$(echo "$PR_URLS_ARRAY" | jq --arg url "$INFRA_PR_URL" '. + [$url]')
          fi
          if [ -n "$CICD_PR_URL" ] && [ "$CICD_PR_URL" != "null" ] && [ "$CICD_PR_URL" != "" ]; then
            PR_URLS_ARRAY=$(echo "$PR_URLS_ARRAY" | jq --arg url "$CICD_PR_URL" '. + [$url]')
          fi
          
          echo "PR_URLS_ARRAY=$PR_URLS_ARRAY" >> $GITHUB_ENV
          echo "pr_urls_array=$PR_URLS_ARRAY" >> $GITHUB_OUTPUT
          echo "PR URLs to save: $PR_URLS_ARRAY"
          
      - name: Create provisioning request entity
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: UPSERT
          identifier: ${{ env.PORT_RUN_ID }}
          title: "Service Provisioning: ${{ github.event.inputs.application_name }}"
          blueprint: provisioningRequest
          runId: ${{ env.PORT_RUN_ID }}
          properties: |
            {
              "resource_name": "${{ github.event.inputs.application_name }}",
              "resource_type": "Service",
              "status": "waiting_approval",
              "pr_urls": ${{ steps.build_pr_urls.outputs.pr_urls_array }},
              "service_repo_url": "${{ steps.setup_repo.outputs.repo_url }}",
              "port_run_link": "https://app.getport.io/organization/run?runId=${{ env.PORT_RUN_ID }}"
            }
          relations: |
            {
              "requestor": "${{ env.REQUESTOR_EMAIL }}"
            }

      - name: Save Terraform plan to provisioning request entity
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: UPSERT
          identifier: ${{ env.PORT_RUN_ID }}
          blueprint: provisioningRequest
          runId: ${{ env.PORT_RUN_ID }}
          properties: ${{ steps.build_plan_properties.outputs.PROPERTIES_JSON }}

          link: |
            ["${{ steps.create_infra_pr.outputs.pull-request-url }}", "${{ steps.create_cicd_pr.outputs.pull-request-url }}"]

